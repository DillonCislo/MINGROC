## MINGROC++ Examples

This folder contains example scripts for using `MINGROC++` from within MATLAB. Currently, there is just a simple script that walks users through how to calculate a growth pattern linking two synthetic surfaces. Check back soon for scripts re-creating the examples in the paper, including the growth of a *Parhyale hawaiensis* limb bud, once the review process is complete!

The primary engine for the optimization is the *Beltrami holomorphic flow* (see the [original paper](https://link.springer.com/article/10.1007/s10915-011-9506-2) by Lui *et al.* or check Appendices A and B of our paper for a digestible summary). We have souped up the original implementation to work with a more sophisicated quasi-Newton descent algorithm (among other changes - see documentation for details). This is a powerful algorithm, designed and adapted to address a difficult computational problem, and it has some idiosyncracies. In particular, the magnitude of the gradient of terms that depend directly on the Beltrami coefficient (e.g. $|\nabla \gamma|^2$) tend to be smaller than the magnitude of the terms that depend implicitly on the Beltrami coeffient through the Beltrami holomorphic flow (e.g. $|\nabla \Gamma|^2|$). Practically, what this means is that when both sets of terms are updated simultaneously, the optimization steps tend to favor the latter terms, even for similar energy contributions.

To get around this, we have built two types of optimization modes: `simultaneous` and `alternating`. In `simultaneous` mode, both sets of terms are updated at the same time. This mode requires less tuning, but is subject to the caveat mentioned above. In `alternating` mode, user defined numbers of steps are taken minimizing each batch of terms separately (similar to block-coordinate descent). This sometimes allows you to blast past difficult nadirs in the energy landscape  (especially when the mesh triangles become highly deformed), but is more sensitive to optimization parameters (number of coordinate descent steps etc.). Typically starting with `simultaneous` mode is a good first step, and then exploring different settings in `alternating` mode can help you find overcome stuck points, or even find different local minima. The exact numbers/vertex positions in the output can change based on settings, but the coarse features of the optimization are typically robust regardless of the mode used. For critical applications, you should take the time to explore different settings to make sure you trust the output.